{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"","title":"Home"},{"location":"CodeReference/Diagnostics.html","text":"Basic Diagnostics Project Diagnostics in this documentation focuses on troubleshooting during active project development, and does not provide functionality for Alarm Handling on a production system. Those functionalities must be added to this project on an application-specific basis. Several tools are made available in this project file to make development as quick and easy as possible, such as: Object status information Function block error codes Mover activity Event Log User Log Events As a starting point, always be sure to investigate the object status outputs in the variable viewer inside TwinCAT. Here we can immediately see a Mover which is: Currently destined for Station #0 Most recently commanded via Position Trigger #2 Has no active errors For more advanced troubleshooting steps, see the additional categories to the left.","title":"Basics"},{"location":"CodeReference/Diagnostics.html#basic-diagnostics","text":"Project Diagnostics in this documentation focuses on troubleshooting during active project development, and does not provide functionality for Alarm Handling on a production system. Those functionalities must be added to this project on an application-specific basis. Several tools are made available in this project file to make development as quick and easy as possible, such as: Object status information Function block error codes Mover activity Event Log User Log Events As a starting point, always be sure to investigate the object status outputs in the variable viewer inside TwinCAT. Here we can immediately see a Mover which is: Currently destined for Station #0 Most recently commanded via Position Trigger #2 Has no active errors For more advanced troubleshooting steps, see the additional categories to the left.","title":"Basic Diagnostics"},{"location":"CodeReference/ErrorMovers.html","text":"ErrorMovers Invalid References Objectives that return References to MoverLists or Movers have the potential to return invalid references. For example, a Station with no mover present can't possibly return a CurrentMover, because by definition no CurrentMover exists! To prevent this, it is important to ensure that all CurrentMover and CurrentMoverList output properties are only evaluated when a MoverInPosition , MoverPassedPosition , MoverInVelocity , etc. flag is true for the relevant Objective. 1 2 3 4 // There is no CurrentMover at the Station, so this code will not operate correctly!! IF Station [ 1 ]. MoverInPosition = FALSE THEN Station [ 1 ]. CurrentMover . MoveToPosition ( 200 ); END_IF Typically, calling methods on these invalid references would result in a Pagefault and halt the XAR. However this outcome can be frustrating and slows development. Instead, an imposter ErrorMover object is returned in these circumstances as a quality-of-life improvement. ErrorMovers replace all the method functionality of standard Movers and will instead generate Errors in TwinCAT. For example: Axis Linking If ErrorMovers appear in the list of potentially linkable objects when connecting NC Axes to PLC axes, ensure that these objects are not selected. By default, ErrorMovers are removed from the PLC Process Image to prevent them appearing in this list.","title":"ErrorMovers"},{"location":"CodeReference/ErrorMovers.html#errormovers","text":"","title":"ErrorMovers"},{"location":"CodeReference/ErrorMovers.html#invalid-references","text":"Objectives that return References to MoverLists or Movers have the potential to return invalid references. For example, a Station with no mover present can't possibly return a CurrentMover, because by definition no CurrentMover exists! To prevent this, it is important to ensure that all CurrentMover and CurrentMoverList output properties are only evaluated when a MoverInPosition , MoverPassedPosition , MoverInVelocity , etc. flag is true for the relevant Objective. 1 2 3 4 // There is no CurrentMover at the Station, so this code will not operate correctly!! IF Station [ 1 ]. MoverInPosition = FALSE THEN Station [ 1 ]. CurrentMover . MoveToPosition ( 200 ); END_IF Typically, calling methods on these invalid references would result in a Pagefault and halt the XAR. However this outcome can be frustrating and slows development. Instead, an imposter ErrorMover object is returned in these circumstances as a quality-of-life improvement. ErrorMovers replace all the method functionality of standard Movers and will instead generate Errors in TwinCAT. For example:","title":"Invalid References"},{"location":"CodeReference/ErrorMovers.html#axis-linking","text":"If ErrorMovers appear in the list of potentially linkable objects when connecting NC Axes to PLC axes, ensure that these objects are not selected. By default, ErrorMovers are removed from the PLC Process Image to prevent them appearing in this list.","title":"Axis Linking"},{"location":"CodeReference/EventLogger.html","text":"Event Logger When the occasional programmed instruction leads to unexpected Mover behavior, it can be useful to look back at a logged history of Mover Events. In this project, every command issued to any Mover on the track is submitted as a log entry which can be viewed in TwinCAT: User Events To make filtering through these events even easier, customer User Events can also be submitted to the Log. See Mover.LogUserEvent for more information.","title":"Event Logger"},{"location":"CodeReference/EventLogger.html#event-logger","text":"When the occasional programmed instruction leads to unexpected Mover behavior, it can be useful to look back at a logged history of Mover Events. In this project, every command issued to any Mover on the track is submitted as a log entry which can be viewed in TwinCAT:","title":"Event Logger"},{"location":"CodeReference/EventLogger.html#user-events","text":"To make filtering through these events even easier, customer User Events can also be submitted to the Log. See Mover.LogUserEvent for more information.","title":"User Events"},{"location":"CodeReference/Mover.html","text":"Mover Object The Mover function block is the heart of the solution. It contains essential functionality, including: Basic administrative commands like enabling & resetting Easily commanding movements to absolute positions or stations Reading out current move status information like position, velocity, etc. Updating motion parameters during operation Setup & Execution It is recommended, but not required, to declare Movers as an array. 1 2 3 4 // Instance declaration Mover : ARRAY [ 0. . GVL . NUM_MOVERS - 1 ] OF Mover ; ParameterSet : MoverParameters_typ ; Movers contain a Cyclic() method that must be called every cycle. This cyclic method must also be given a Collision Avoidance Group reference as an argument. 1 2 3 4 // Call this method cyclically FOR i := 0 TO GVL . NUM_MOVERS - 1 ] DO Mover [ i ]. Cyclic ( GroupRef ); END_FOR Methods Enable Enable() Carries out steps to prepare the Mover for motion commands. An internal MC_Reset function block is called to reset any errors that may exist on the Axis object. The mover will read M1 Detection Settings configured in the XtsProcessingUnit. If M1 Detection is configured, the Mover will activate this process to find Mover 1. If this is not configured, this step is skipped. An internal MC_Power function block is called to energize the axis object. The mover will automatically add itself to a Collision Avoidance group, and if necessary will also automatically enable this group. The mover will set its Ready output True. 1 Mover [ 1 ]. Enable (); Disable Disable() Disables the mover. Holding Torque will be lost. Method will automatically remove the mover from its Collision Avoidance group. 1 Mover [ 1 ]. Disable (); GroupStop GroupStop() Immediately stops all enabled movers on the system with the deceleration parameters of the mover on which the method was called. Since the method acts upon the collision avoidance group, all enabled movers on the system are immediately stopped and any active movements are cancelled. New motion commands to each mover are ignored until the Stop has completed. 1 2 3 4 IF xStopAllMovers THEN Mover [ 0 ]. GroupStop (); xStopAllMovers := FALSE ; END_IF Halt Halt() Immediately stops the commanded mover with the deceleration parameters stored in the Mover object Halt does not alter the mover's internal axis state, so new movements can be executed at any point to send the mover onwards. 1 2 3 4 IF xStopSingleMover THEN Mover [ 0 ]. Halt (); xStopSingleMover := FALSE ; END_IF MoveToPosition MoveToPosition( Destination : LREAL ) Executes an Absolute Move (with Collision Avoidance) to the target location. 1 2 3 4 IF xMoveCommand THEN Mover [ 1 ]. MoveToPosition ( 1200 ); xMoveCommand := FALSE ; END_IF MoveToStation MoveToStation( Destination : Station ) Executes an Absolute Move (with Collision Avoidance) to the location of the target Station, and implicitly calls that Station's RegisterMover method. 1 2 3 4 IF xMoveToHome THEN Mover [ 1 ]. MoveToStation ( Station [ 1 ] ); xMoveToHome := FALSE ; END_IF MoveVelocity MoveVelocity( DesiredVelocity : LREAL ) Executes a Velocity movement (with Collision Avoidance) at the specified Velocity. This command also implicitly updates the Mover's internal Velocity Motion Parameter. 1 2 3 4 IF xMoveVelocity THEN Mover [ 1 ]. MoveVelocity ( 2000 ); xMoveVelocity := FALSE ; END_IF SyncToMover SyncToMover( MasterMover : Mover, Gap : LREAL ) Pairs the current mover with a desired mover at a specified gap distance. The current mover will immediately move (with CA) to a specified distance from the Master Mover and then mimic all motion from the master. The synchronization can be ended by executing a call on the slave for any other motion command, e.g. MoveToPosition. Gap specifies a center-to-center following distance between master and slave movers. This gap cannot be achieved if it is below the minimum collision avoidance distance established in the CA group. Positive Gap values will result in a following position behind the master and negative values will result in a slave that precedes the master. Additional calls to this method can be used to update the gap between paired movers. 1 2 3 4 5 6 7 IF xCmdSyncToLeader THEN Mover [ 0 ]. SyncToMover ( Mover [ 1 ], 100 ); // move 100mm away from Mover 1 IF Mover [ 0 ]. IsSyncedToMover THEN Mover [ 1 ]. MoveToPosition ( 2000 ); // Master moves to 2000 and Mover 0 will follow END_IF ; END_IF ; 1 2 3 4 5 6 7 8 9 10 11 IF xBuildTrain THEN Mover [ 3 ]. SyncToMover ( Mover [ 4 ], 100 ); Mover [ 2 ]. SyncToMover ( Mover [ 4 ], 200 ); Mover [ 1 ]. SyncToMover ( Mover [ 4 ], 300 ); Mover [ 0 ]. SyncToMover ( Mover [ 4 ], 400 ); IF Mover [ 0 ]. IsSyncedToMover THEN // Commands Mover 4 to move ahead at 300 mm/s Mover [ 0 ]. MasterMover . MoveVelocity ( 300 ); END_IF ; END_IF ; ReissueCommand ReissueCommand() Executes the latest command that was issued to the mover, e.g. a MoveToPosition command. The move is executed with the current internal Motion Parameters of the Mover, so the dynamics of the mover may not exactly match what was initially commanded. However, in cases of MoveToPosition or MoveToStation, the destination will be the same. To determine what type of movement ReissueCommand() will repeat, see Mover properties CurrentMoveType, CurrentObjective, and CurrentDestinationPosition. 1 2 3 4 5 6 7 8 9 10 11 12 // Issue a primary command IF xInitialCommand THEN Mover [ 1 ]. SetVelocity ( 500 ); Mover [ 1 ]. MoveToPosition ( 1000 ); xInitialCommand := FALSE ; // Reissue the primary command, but with a new velocity parameter ELSIF xUpdateCommand THEN Mover [ 1 ]. SetVelocity ( 750 ); Mover [ 1 ]. ReissueCommand (); xUpdateCommand := FALSE ; END_IF LogUserEvent LogUserEvent( Text1 : STRING, Text2 : STRING, Text3 : STRING ) Submits custom log events to the Event Logger which can be viewed in TwinCAT 1 2 3 IF PositionTrigger [ 1 ]. MoverPassedPosition THEN PositionTrigger [ 1 ]. CurrentMover . LogUserEvent ( 'Mover Passed PT#1' , '' , '' ); END_IF ; SetAcceleration SetAcceleration( DesiredAccel : LREAL ) Updates the Mover's internal Motion Parameter for Acceleration [mm/s2] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xCommandHighAccel THEN Mover [ 1 ]. SetAcceleration ( 2e4 ); // mm/s2 xCommandHighAccel := FALSE ; END_IF SetDeceleration SetDeceleration( DesiredDecel : LREAL ) Updates the Mover's internal Motion Parameter for Deceleration [mm/s2] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xCommandLowDecel THEN Mover [ 1 ]. SetDeceleration ( 1e3 ); // mm/s2 xCommandLowDecel := FALSE ; END_IF SetDirection SetDirection( Direction : Tc3_Mc3Definitions.MC_Direction ); Updates the Mover's internal Motion Parameter for Direction and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately This method should only be used with care, and an understanding that a mover enroute will immediately reverse course and execute a motion command in the opposite direction when this method is called. 1 2 3 4 5 6 // For supported directions, see Infosys IF xReverseDirection THEN Mover [ 1 ]. SetDirection ( mcDirectionPositive ); xReverseDirection := FALSE ; END_IF SetJerk SetJerk( Jerk : LREAL ) Updates the Mover's internal Motion Parameter for Jerk [mm/s3] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xUpdateJerk THEN Mover [ 1 ]. UpdateJerk ( 1e5 ); xUpdateJerk := FALSE ; END_IF SetVelocity SetVelocity( DesiredVelocity : LREAL ) Updates the Mover's internal Motion Parameter for Velocity [mm/s] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xCommandSlowMode THEN Mover [ 1 ]. SetVelocity ( 500 ); // mm/s xCommandSlowMode := FALSE ; END_IF Properties .CurrentMoveType MoverCommandType_enum 1 2 3 4 MOVETYPE_NONE // this mover was just enabled and has no movement history MOVETYPE_POSITION // this mover was most recently issued a MoveToPosition command MOVETYPE_STATION // this mover was most recently issued a MoveToStation command MOVETYPE_VELOCITY // this mover was most recently issued a MoveVelocity command Provides the current (last executed) type of movement command issued to the Mover .CurrentDestinationPosition LREAL Provides the current destination position for the last movement command issued to the Mover. For Station commands, this will be the TrackPosition of the Station. For Velocity commands with no real destination position, the value is set to +/-1E300. .MotionParameters MotionParameters_typ Defines a structure containing the dynamics settings for the Mover. Any new motion commands issued will utilize these values. Note: despite listing this value as a Property here in the documentation, MotionParameters are actually defined as a regular Input to the Mover object. This allows component access to the members of the STRUCT, which is not possible for Properties. .CurrentObjective STRING Provides the current Objective destination for the Mover. Right now this is only valid when the Mover is destined for a Station objective, and provides a string name for that station. .IsSyncedToMover BOOL Returns true if the mover is slaved to another mover and has successfully reached the following position specified by the Gap. .MasterMover REFERENCE To Mover Reference variable that refers to the Mover this Mover is currently slaved to When this mover is not slaved to another mover, .MasterMover is an invalid reference. There is therefore an ErrorMover object which will return information on what action was requested by the object while .MasterMover was invalid. This will show up in TwinCAT's Event Logs. See Diagnostics>ErrorMovers for more information. It is recommended that all evaluations are nested inside IF checks for .IsSyncedToMover OR by calling __ISVALIDREF .Payload !!! Under Construction !!! At the moment, this property is a placeholder for application specific information regarding the current status of products onboard the mover, and can be modified as needed for your application. Extra Examples Below are simple examples of different operations utilizing the Mover object: 1 2 3 // Mover: ARRAY [0..GVL.NUM_MOVERS] OF Mover Mover [ 1 ]. SetVelocity ( 2500 ); Mover [ 1 ]. MoveToPosition ( 1200 );","title":"Mover"},{"location":"CodeReference/Mover.html#mover-object","text":"The Mover function block is the heart of the solution. It contains essential functionality, including: Basic administrative commands like enabling & resetting Easily commanding movements to absolute positions or stations Reading out current move status information like position, velocity, etc. Updating motion parameters during operation","title":"Mover Object"},{"location":"CodeReference/Mover.html#setup-execution","text":"It is recommended, but not required, to declare Movers as an array. 1 2 3 4 // Instance declaration Mover : ARRAY [ 0. . GVL . NUM_MOVERS - 1 ] OF Mover ; ParameterSet : MoverParameters_typ ; Movers contain a Cyclic() method that must be called every cycle. This cyclic method must also be given a Collision Avoidance Group reference as an argument. 1 2 3 4 // Call this method cyclically FOR i := 0 TO GVL . NUM_MOVERS - 1 ] DO Mover [ i ]. Cyclic ( GroupRef ); END_FOR","title":"Setup &amp; Execution"},{"location":"CodeReference/Mover.html#methods","text":"","title":"Methods"},{"location":"CodeReference/Mover.html#enable","text":"Enable() Carries out steps to prepare the Mover for motion commands. An internal MC_Reset function block is called to reset any errors that may exist on the Axis object. The mover will read M1 Detection Settings configured in the XtsProcessingUnit. If M1 Detection is configured, the Mover will activate this process to find Mover 1. If this is not configured, this step is skipped. An internal MC_Power function block is called to energize the axis object. The mover will automatically add itself to a Collision Avoidance group, and if necessary will also automatically enable this group. The mover will set its Ready output True. 1 Mover [ 1 ]. Enable ();","title":"Enable"},{"location":"CodeReference/Mover.html#disable","text":"Disable() Disables the mover. Holding Torque will be lost. Method will automatically remove the mover from its Collision Avoidance group. 1 Mover [ 1 ]. Disable ();","title":"Disable"},{"location":"CodeReference/Mover.html#groupstop","text":"GroupStop() Immediately stops all enabled movers on the system with the deceleration parameters of the mover on which the method was called. Since the method acts upon the collision avoidance group, all enabled movers on the system are immediately stopped and any active movements are cancelled. New motion commands to each mover are ignored until the Stop has completed. 1 2 3 4 IF xStopAllMovers THEN Mover [ 0 ]. GroupStop (); xStopAllMovers := FALSE ; END_IF","title":"GroupStop"},{"location":"CodeReference/Mover.html#halt","text":"Halt() Immediately stops the commanded mover with the deceleration parameters stored in the Mover object Halt does not alter the mover's internal axis state, so new movements can be executed at any point to send the mover onwards. 1 2 3 4 IF xStopSingleMover THEN Mover [ 0 ]. Halt (); xStopSingleMover := FALSE ; END_IF","title":"Halt"},{"location":"CodeReference/Mover.html#movetoposition","text":"MoveToPosition( Destination : LREAL ) Executes an Absolute Move (with Collision Avoidance) to the target location. 1 2 3 4 IF xMoveCommand THEN Mover [ 1 ]. MoveToPosition ( 1200 ); xMoveCommand := FALSE ; END_IF","title":"MoveToPosition"},{"location":"CodeReference/Mover.html#movetostation","text":"MoveToStation( Destination : Station ) Executes an Absolute Move (with Collision Avoidance) to the location of the target Station, and implicitly calls that Station's RegisterMover method. 1 2 3 4 IF xMoveToHome THEN Mover [ 1 ]. MoveToStation ( Station [ 1 ] ); xMoveToHome := FALSE ; END_IF","title":"MoveToStation"},{"location":"CodeReference/Mover.html#movevelocity","text":"MoveVelocity( DesiredVelocity : LREAL ) Executes a Velocity movement (with Collision Avoidance) at the specified Velocity. This command also implicitly updates the Mover's internal Velocity Motion Parameter. 1 2 3 4 IF xMoveVelocity THEN Mover [ 1 ]. MoveVelocity ( 2000 ); xMoveVelocity := FALSE ; END_IF","title":"MoveVelocity"},{"location":"CodeReference/Mover.html#synctomover","text":"SyncToMover( MasterMover : Mover, Gap : LREAL ) Pairs the current mover with a desired mover at a specified gap distance. The current mover will immediately move (with CA) to a specified distance from the Master Mover and then mimic all motion from the master. The synchronization can be ended by executing a call on the slave for any other motion command, e.g. MoveToPosition. Gap specifies a center-to-center following distance between master and slave movers. This gap cannot be achieved if it is below the minimum collision avoidance distance established in the CA group. Positive Gap values will result in a following position behind the master and negative values will result in a slave that precedes the master. Additional calls to this method can be used to update the gap between paired movers. 1 2 3 4 5 6 7 IF xCmdSyncToLeader THEN Mover [ 0 ]. SyncToMover ( Mover [ 1 ], 100 ); // move 100mm away from Mover 1 IF Mover [ 0 ]. IsSyncedToMover THEN Mover [ 1 ]. MoveToPosition ( 2000 ); // Master moves to 2000 and Mover 0 will follow END_IF ; END_IF ; 1 2 3 4 5 6 7 8 9 10 11 IF xBuildTrain THEN Mover [ 3 ]. SyncToMover ( Mover [ 4 ], 100 ); Mover [ 2 ]. SyncToMover ( Mover [ 4 ], 200 ); Mover [ 1 ]. SyncToMover ( Mover [ 4 ], 300 ); Mover [ 0 ]. SyncToMover ( Mover [ 4 ], 400 ); IF Mover [ 0 ]. IsSyncedToMover THEN // Commands Mover 4 to move ahead at 300 mm/s Mover [ 0 ]. MasterMover . MoveVelocity ( 300 ); END_IF ; END_IF ;","title":"SyncToMover"},{"location":"CodeReference/Mover.html#reissuecommand","text":"ReissueCommand() Executes the latest command that was issued to the mover, e.g. a MoveToPosition command. The move is executed with the current internal Motion Parameters of the Mover, so the dynamics of the mover may not exactly match what was initially commanded. However, in cases of MoveToPosition or MoveToStation, the destination will be the same. To determine what type of movement ReissueCommand() will repeat, see Mover properties CurrentMoveType, CurrentObjective, and CurrentDestinationPosition. 1 2 3 4 5 6 7 8 9 10 11 12 // Issue a primary command IF xInitialCommand THEN Mover [ 1 ]. SetVelocity ( 500 ); Mover [ 1 ]. MoveToPosition ( 1000 ); xInitialCommand := FALSE ; // Reissue the primary command, but with a new velocity parameter ELSIF xUpdateCommand THEN Mover [ 1 ]. SetVelocity ( 750 ); Mover [ 1 ]. ReissueCommand (); xUpdateCommand := FALSE ; END_IF","title":"ReissueCommand"},{"location":"CodeReference/Mover.html#loguserevent","text":"LogUserEvent( Text1 : STRING, Text2 : STRING, Text3 : STRING ) Submits custom log events to the Event Logger which can be viewed in TwinCAT 1 2 3 IF PositionTrigger [ 1 ]. MoverPassedPosition THEN PositionTrigger [ 1 ]. CurrentMover . LogUserEvent ( 'Mover Passed PT#1' , '' , '' ); END_IF ;","title":"LogUserEvent"},{"location":"CodeReference/Mover.html#setacceleration","text":"SetAcceleration( DesiredAccel : LREAL ) Updates the Mover's internal Motion Parameter for Acceleration [mm/s2] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xCommandHighAccel THEN Mover [ 1 ]. SetAcceleration ( 2e4 ); // mm/s2 xCommandHighAccel := FALSE ; END_IF","title":"SetAcceleration"},{"location":"CodeReference/Mover.html#setdeceleration","text":"SetDeceleration( DesiredDecel : LREAL ) Updates the Mover's internal Motion Parameter for Deceleration [mm/s2] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xCommandLowDecel THEN Mover [ 1 ]. SetDeceleration ( 1e3 ); // mm/s2 xCommandLowDecel := FALSE ; END_IF","title":"SetDeceleration"},{"location":"CodeReference/Mover.html#setdirection","text":"SetDirection( Direction : Tc3_Mc3Definitions.MC_Direction ); Updates the Mover's internal Motion Parameter for Direction and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately This method should only be used with care, and an understanding that a mover enroute will immediately reverse course and execute a motion command in the opposite direction when this method is called. 1 2 3 4 5 6 // For supported directions, see Infosys IF xReverseDirection THEN Mover [ 1 ]. SetDirection ( mcDirectionPositive ); xReverseDirection := FALSE ; END_IF","title":"SetDirection"},{"location":"CodeReference/Mover.html#setjerk","text":"SetJerk( Jerk : LREAL ) Updates the Mover's internal Motion Parameter for Jerk [mm/s3] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xUpdateJerk THEN Mover [ 1 ]. UpdateJerk ( 1e5 ); xUpdateJerk := FALSE ; END_IF","title":"SetJerk"},{"location":"CodeReference/Mover.html#setvelocity","text":"SetVelocity( DesiredVelocity : LREAL ) Updates the Mover's internal Motion Parameter for Velocity [mm/s] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xCommandSlowMode THEN Mover [ 1 ]. SetVelocity ( 500 ); // mm/s xCommandSlowMode := FALSE ; END_IF","title":"SetVelocity"},{"location":"CodeReference/Mover.html#properties","text":"","title":"Properties"},{"location":"CodeReference/Mover.html#currentmovetype","text":"MoverCommandType_enum 1 2 3 4 MOVETYPE_NONE // this mover was just enabled and has no movement history MOVETYPE_POSITION // this mover was most recently issued a MoveToPosition command MOVETYPE_STATION // this mover was most recently issued a MoveToStation command MOVETYPE_VELOCITY // this mover was most recently issued a MoveVelocity command Provides the current (last executed) type of movement command issued to the Mover","title":".CurrentMoveType"},{"location":"CodeReference/Mover.html#currentdestinationposition","text":"LREAL Provides the current destination position for the last movement command issued to the Mover. For Station commands, this will be the TrackPosition of the Station. For Velocity commands with no real destination position, the value is set to +/-1E300.","title":".CurrentDestinationPosition"},{"location":"CodeReference/Mover.html#motionparameters","text":"MotionParameters_typ Defines a structure containing the dynamics settings for the Mover. Any new motion commands issued will utilize these values. Note: despite listing this value as a Property here in the documentation, MotionParameters are actually defined as a regular Input to the Mover object. This allows component access to the members of the STRUCT, which is not possible for Properties.","title":".MotionParameters"},{"location":"CodeReference/Mover.html#currentobjective","text":"STRING Provides the current Objective destination for the Mover. Right now this is only valid when the Mover is destined for a Station objective, and provides a string name for that station.","title":".CurrentObjective"},{"location":"CodeReference/Mover.html#issyncedtomover","text":"BOOL Returns true if the mover is slaved to another mover and has successfully reached the following position specified by the Gap.","title":".IsSyncedToMover"},{"location":"CodeReference/Mover.html#mastermover","text":"REFERENCE To Mover Reference variable that refers to the Mover this Mover is currently slaved to When this mover is not slaved to another mover, .MasterMover is an invalid reference. There is therefore an ErrorMover object which will return information on what action was requested by the object while .MasterMover was invalid. This will show up in TwinCAT's Event Logs. See Diagnostics>ErrorMovers for more information. It is recommended that all evaluations are nested inside IF checks for .IsSyncedToMover OR by calling __ISVALIDREF","title":".MasterMover"},{"location":"CodeReference/Mover.html#payload","text":"!!! Under Construction !!! At the moment, this property is a placeholder for application specific information regarding the current status of products onboard the mover, and can be modified as needed for your application.","title":".Payload"},{"location":"CodeReference/Mover.html#extra-examples","text":"Below are simple examples of different operations utilizing the Mover object: 1 2 3 // Mover: ARRAY [0..GVL.NUM_MOVERS] OF Mover Mover [ 1 ]. SetVelocity ( 2500 ); Mover [ 1 ]. MoveToPosition ( 1200 );","title":"Extra Examples"},{"location":"CodeReference/MoverList.html","text":"Mover List Object The Mover List object provides a way to group Movers together and issue commands to every Mover in the list. Alternatively, commands can be sent to individual movers within the list based on their geographic proximity to a track position Setup & Execution 1 2 // Declaration MoverListA : MoverList ; 1 2 3 4 5 6 7 8 9 // Usage MoverListA . RegisterMover ( Mover [ 1 ] ); MoverListA . RegisterMover ( Mover [ 2 ] ); MoverListA . RegisterMover ( Mover [ 3 ] ); MoverListA . SetAllVelocity ( 1000 ); MoverListA . MoveAllToStation ( Station [ 4 ] ); MoverListA . UnregisterAll (); Methods GetMoverByLocation GetMoverByLocation( Index : USINT, Position : LREAL, Direction : Tc2_MC2.MC_Direction ) : REFERENCE TO Mover Returns a reference to a singular mover from the Mover List, based on it's geographic location relative to a fixed track position. Index specifies the number of movers that should lie between the selection and the Position input. Therefore Index = 0 would be the closest mover to the input position (in a given direction), Index = 1 would be the second closest, Index = 2 would be the third closest, etc. Position specifies the target around which mover proximity should be considered. Direction specifies the direction around the track from which the movers are indexed. Therefore MC_Positive_Direction will begin returning movers with the most positive absolute position values that are still less than the position input. 1 2 3 4 5 6 7 8 9 10 11 // Select a mover in the MoverList // Which is the first closest mover to position 900 // And which has a position less than 900 // Then sends it to a station MoverListA . GetMoverByLocation ( 0 , 900 , MC_Positive_Direction ). MoveToStation ( Station [ 3 ] ); // Select a mover in the MoverList // Which is the third closest mover to position 2000 // And which has a position greater than 3000 // Then sets its acceleration MoverListA . GetMoverByLocation ( 2 , 3000 , MC_Negative_Direction ). SetAcceleration ( 1E4 ); MoveAllToPosition MoveAllToPosition( DestinationPosition : LREAL ) Issues individual MoveToPosition commands to every mover registered with the list. 1 MoverListA . MoveAllToPosition ( 1200 ); MoveAllToStation MoveAllToStation( DestinationStation: Station ) Issues individual MoveToStation commands to every mover registered with the list. 1 MoverListA . MoveAllToStation ( Station [ 3 ] ); MoveAllVelocity MoveAllVelocity( DesiredVelocity : LREAL ) Issues individual MoveVelocity commands to every mover registered with the list. 1 MoverListA . MoveAllVelocity ( 300 ); SetAllAcceleration SetAllAcceleration( DesiredAcceleration : LREAL ) Sets the acceleration motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllAcceleration ( 1E3 ); SetAllDeceleration SetAllDeceleration( DesiredDeceleration : LREAL ) Sets the deceleration motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllDeceleration ( 15000 ); SetAllDirection SetAllDirection( Direction : Tc3_Mc3Definitions.MC_DIRECTION ) Sets the direction motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllDirection ( mcDirectionPositive ); SetAllJerk SetAllJerk( DesiredJerk : LREAL ) Sets the jerk motion parameter equal to the input argument for every mover in the list 1 MoverListA.SetAllJerk( 1e5 ); SetAllVelocity SetAllVelocity( DesiredVelocity : LREAL ) Sets the velocity motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllVelocity ( 2000 ); StopAll StopAll() Stops all movers in the list by calling their individual Stop methods 1 MoverListA . StopAll (); UnregisterAll UnregisterAll() Unregisters every mover from the list immediately 1 MoverListA . UnregisterAll ();","title":"Mover List"},{"location":"CodeReference/MoverList.html#mover-list-object","text":"The Mover List object provides a way to group Movers together and issue commands to every Mover in the list. Alternatively, commands can be sent to individual movers within the list based on their geographic proximity to a track position","title":"Mover List Object"},{"location":"CodeReference/MoverList.html#setup-execution","text":"1 2 // Declaration MoverListA : MoverList ; 1 2 3 4 5 6 7 8 9 // Usage MoverListA . RegisterMover ( Mover [ 1 ] ); MoverListA . RegisterMover ( Mover [ 2 ] ); MoverListA . RegisterMover ( Mover [ 3 ] ); MoverListA . SetAllVelocity ( 1000 ); MoverListA . MoveAllToStation ( Station [ 4 ] ); MoverListA . UnregisterAll ();","title":"Setup &amp; Execution"},{"location":"CodeReference/MoverList.html#methods","text":"","title":"Methods"},{"location":"CodeReference/MoverList.html#getmoverbylocation","text":"GetMoverByLocation( Index : USINT, Position : LREAL, Direction : Tc2_MC2.MC_Direction ) : REFERENCE TO Mover Returns a reference to a singular mover from the Mover List, based on it's geographic location relative to a fixed track position. Index specifies the number of movers that should lie between the selection and the Position input. Therefore Index = 0 would be the closest mover to the input position (in a given direction), Index = 1 would be the second closest, Index = 2 would be the third closest, etc. Position specifies the target around which mover proximity should be considered. Direction specifies the direction around the track from which the movers are indexed. Therefore MC_Positive_Direction will begin returning movers with the most positive absolute position values that are still less than the position input. 1 2 3 4 5 6 7 8 9 10 11 // Select a mover in the MoverList // Which is the first closest mover to position 900 // And which has a position less than 900 // Then sends it to a station MoverListA . GetMoverByLocation ( 0 , 900 , MC_Positive_Direction ). MoveToStation ( Station [ 3 ] ); // Select a mover in the MoverList // Which is the third closest mover to position 2000 // And which has a position greater than 3000 // Then sets its acceleration MoverListA . GetMoverByLocation ( 2 , 3000 , MC_Negative_Direction ). SetAcceleration ( 1E4 );","title":"GetMoverByLocation"},{"location":"CodeReference/MoverList.html#movealltoposition","text":"MoveAllToPosition( DestinationPosition : LREAL ) Issues individual MoveToPosition commands to every mover registered with the list. 1 MoverListA . MoveAllToPosition ( 1200 );","title":"MoveAllToPosition"},{"location":"CodeReference/MoverList.html#movealltostation","text":"MoveAllToStation( DestinationStation: Station ) Issues individual MoveToStation commands to every mover registered with the list. 1 MoverListA . MoveAllToStation ( Station [ 3 ] );","title":"MoveAllToStation"},{"location":"CodeReference/MoverList.html#moveallvelocity","text":"MoveAllVelocity( DesiredVelocity : LREAL ) Issues individual MoveVelocity commands to every mover registered with the list. 1 MoverListA . MoveAllVelocity ( 300 );","title":"MoveAllVelocity"},{"location":"CodeReference/MoverList.html#setallacceleration","text":"SetAllAcceleration( DesiredAcceleration : LREAL ) Sets the acceleration motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllAcceleration ( 1E3 );","title":"SetAllAcceleration"},{"location":"CodeReference/MoverList.html#setalldeceleration","text":"SetAllDeceleration( DesiredDeceleration : LREAL ) Sets the deceleration motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllDeceleration ( 15000 );","title":"SetAllDeceleration"},{"location":"CodeReference/MoverList.html#setalldirection","text":"SetAllDirection( Direction : Tc3_Mc3Definitions.MC_DIRECTION ) Sets the direction motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllDirection ( mcDirectionPositive );","title":"SetAllDirection"},{"location":"CodeReference/MoverList.html#setalljerk","text":"SetAllJerk( DesiredJerk : LREAL ) Sets the jerk motion parameter equal to the input argument for every mover in the list 1 MoverListA.SetAllJerk( 1e5 );","title":"SetAllJerk"},{"location":"CodeReference/MoverList.html#setallvelocity","text":"SetAllVelocity( DesiredVelocity : LREAL ) Sets the velocity motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllVelocity ( 2000 );","title":"SetAllVelocity"},{"location":"CodeReference/MoverList.html#stopall","text":"StopAll() Stops all movers in the list by calling their individual Stop methods 1 MoverListA . StopAll ();","title":"StopAll"},{"location":"CodeReference/MoverList.html#unregisterall","text":"UnregisterAll() Unregisters every mover from the list immediately 1 MoverListA . UnregisterAll ();","title":"UnregisterAll"},{"location":"CodeReference/Objectives.html","text":"Project Overview Broad Concept The core concept driving the project structure is that it is useful to address movers contextually as opposed to directly . To illustrate, consider a scenario of recovering from an E-Stop where a robot is positioned directly in the path of the movers. In this instance, a first step might be to command any movers downstream of the robot to move further downstream, and movers upstream of the robot should be commanded further upstream in order to create some space for the arm to reset. As a programmer, one wouldn't seek to specifically command Mover #4 and Mover #5 to carry out those instructions because during the next occurence it may be an entirely different pair of movers in this situation. Instead, the commands are issued to whichever movers are closest to the robot right now . In this sense, we take a list of all movers on the track system, and apply filters to help select only the movers we care to command. These filters are applied via a family of objects called Objectives. Objectives Objective is an umbrella term used by the project, that includes the following objects: Stations Zones SpeedTriggers PositionTriggers MoverLists Each Objective defines a set criteria that a Mover can either fulfill or not at any given point. As an example, a Mover fulfills the criteria of a Station when it is parked at the Station's configured track position. When a Mover satisfies the requirements of the Objective , the Objective provides a Reference to the Mover through which new Mover commands can be issued. .CurrentMover CurrentMover is the Reference output through which Movers can be addressed contextually via an Objective. Let's look at a simple example: 1 2 Station [ 3 ]. CurrentMover ; // is equivalent to... Mover [ 4 ]; // as long as Mover #4 is parked at Station#3 And as a Reference, this CurrentMover output accepts any Method call instructions that a base Mover object could. E.g.: 1 2 Station [ 3 ]. CurrentMover . SetVelocity ( 2000 ); // is equivalent to... Mover [ 4 ]. SetVelocity ( 2000 ); // so long as the the Mover is parked as above Common Methods The objects listed above all share some common methods, which are implemented in the parent Objective base class. RegisterMover RegisterMover( NewMover : Mover ) Adds a Mover to the list of Tracked Movers that the objective is currently monitoring. If the input Mover has already been added to the Tracked Movers list, the method call is ignored. 1 2 Mover [ 1 ]. MoveToPosition ( Station [ 1 ]. TrackPosition ); Station [ 1 ]. RegisterMover ( Mover [ 1 ] ); The code above is similar in functionality to: 1 Mover [ 1 ]. MoveToStation ( Station [ 1 ] ); Stations include some unique features regarding mover registration. See Station Object for more details. UnregisterMover RegisterMover( ExistingMover : Mover ) Removes a Mover from the list of Tracked Movers that the objective is currently monitoring. If the input Mover is not already tracked by the objective, the method call is ignored. 1 2 Mover [ 1 ]. MoveToStation ( Station [ 1 ] ); Station [ 1 ]. UnregisterMover ( Mover [ 1 ] ); Because the Mover would not be registered with the Station when it arrives, the Station would not report that the Mover is InPosition. The code above is functionally identical to: 1 Mover [ 1 ]. MoveToPosition ( Station [ 1 ]. TrackPosition ); UnregisterCurrent UnregisterCurrent( ) Automatically unregisters whatever mover is listed as CurrentMover for the Objective Here the MoverInPosition status output changes. The mover is still physically located at the Station position, but since it is no longer registered, it cannot report MoverInPosition. 1 2 3 bCheck := Station [ 1 ]. MoverInPosition ; // returns TRUE Station [ 1 ]. UnregisterCurrent (); bCheck := Station [ 1 ]. MoverInPosition ; // returns FALSE 1 2 3 4 IF PositionTrigger [ 1 ]. MoverPassedPosition THEN PositionTrigger [ 1 ]. CurrentMover . SetVelocity ( 200 ); PositionTrigger [ 1 ]. UnregisterCurrent (); END_IF UnregisterAll UnregisterAll() Automatically unregisters every mover from the Tracked Movers list 1 2 3 4 IF xClearTrigger THEN PositionTrigger [ 2 ]. UnregisterAll (); xClearTrigger := FALSE ; END_IF","title":"Overview"},{"location":"CodeReference/Objectives.html#project-overview","text":"","title":"Project Overview"},{"location":"CodeReference/Objectives.html#broad-concept","text":"The core concept driving the project structure is that it is useful to address movers contextually as opposed to directly . To illustrate, consider a scenario of recovering from an E-Stop where a robot is positioned directly in the path of the movers. In this instance, a first step might be to command any movers downstream of the robot to move further downstream, and movers upstream of the robot should be commanded further upstream in order to create some space for the arm to reset. As a programmer, one wouldn't seek to specifically command Mover #4 and Mover #5 to carry out those instructions because during the next occurence it may be an entirely different pair of movers in this situation. Instead, the commands are issued to whichever movers are closest to the robot right now . In this sense, we take a list of all movers on the track system, and apply filters to help select only the movers we care to command. These filters are applied via a family of objects called Objectives.","title":"Broad Concept"},{"location":"CodeReference/Objectives.html#objectives","text":"Objective is an umbrella term used by the project, that includes the following objects: Stations Zones SpeedTriggers PositionTriggers MoverLists Each Objective defines a set criteria that a Mover can either fulfill or not at any given point. As an example, a Mover fulfills the criteria of a Station when it is parked at the Station's configured track position. When a Mover satisfies the requirements of the Objective , the Objective provides a Reference to the Mover through which new Mover commands can be issued.","title":"Objectives"},{"location":"CodeReference/Objectives.html#currentmover","text":"CurrentMover is the Reference output through which Movers can be addressed contextually via an Objective. Let's look at a simple example: 1 2 Station [ 3 ]. CurrentMover ; // is equivalent to... Mover [ 4 ]; // as long as Mover #4 is parked at Station#3 And as a Reference, this CurrentMover output accepts any Method call instructions that a base Mover object could. E.g.: 1 2 Station [ 3 ]. CurrentMover . SetVelocity ( 2000 ); // is equivalent to... Mover [ 4 ]. SetVelocity ( 2000 ); // so long as the the Mover is parked as above","title":".CurrentMover"},{"location":"CodeReference/Objectives.html#common-methods","text":"The objects listed above all share some common methods, which are implemented in the parent Objective base class.","title":"Common Methods"},{"location":"CodeReference/Objectives.html#registermover","text":"RegisterMover( NewMover : Mover ) Adds a Mover to the list of Tracked Movers that the objective is currently monitoring. If the input Mover has already been added to the Tracked Movers list, the method call is ignored. 1 2 Mover [ 1 ]. MoveToPosition ( Station [ 1 ]. TrackPosition ); Station [ 1 ]. RegisterMover ( Mover [ 1 ] ); The code above is similar in functionality to: 1 Mover [ 1 ]. MoveToStation ( Station [ 1 ] ); Stations include some unique features regarding mover registration. See Station Object for more details.","title":"RegisterMover"},{"location":"CodeReference/Objectives.html#unregistermover","text":"RegisterMover( ExistingMover : Mover ) Removes a Mover from the list of Tracked Movers that the objective is currently monitoring. If the input Mover is not already tracked by the objective, the method call is ignored. 1 2 Mover [ 1 ]. MoveToStation ( Station [ 1 ] ); Station [ 1 ]. UnregisterMover ( Mover [ 1 ] ); Because the Mover would not be registered with the Station when it arrives, the Station would not report that the Mover is InPosition. The code above is functionally identical to: 1 Mover [ 1 ]. MoveToPosition ( Station [ 1 ]. TrackPosition );","title":"UnregisterMover"},{"location":"CodeReference/Objectives.html#unregistercurrent","text":"UnregisterCurrent( ) Automatically unregisters whatever mover is listed as CurrentMover for the Objective Here the MoverInPosition status output changes. The mover is still physically located at the Station position, but since it is no longer registered, it cannot report MoverInPosition. 1 2 3 bCheck := Station [ 1 ]. MoverInPosition ; // returns TRUE Station [ 1 ]. UnregisterCurrent (); bCheck := Station [ 1 ]. MoverInPosition ; // returns FALSE 1 2 3 4 IF PositionTrigger [ 1 ]. MoverPassedPosition THEN PositionTrigger [ 1 ]. CurrentMover . SetVelocity ( 200 ); PositionTrigger [ 1 ]. UnregisterCurrent (); END_IF","title":"UnregisterCurrent"},{"location":"CodeReference/Objectives.html#unregisterall","text":"UnregisterAll() Automatically unregisters every mover from the Tracked Movers list 1 2 3 4 IF xClearTrigger THEN PositionTrigger [ 2 ]. UnregisterAll (); xClearTrigger := FALSE ; END_IF","title":"UnregisterAll"},{"location":"CodeReference/PositionTrigger.html","text":"Position Trigger Object Position Trigger objects monitor movers until they have crossed over a specified location on track, even if they do not stop there. Setup & Execution 1 2 // Declaration PositionTriggerA : PositionTrigger ; 1 2 3 // Initialization PositionTriggerA . TrackPosition := 2000 ; PositionTriggerA . TriggerDirection := mcDirectionPositive ; Methods Cyclic Cyclic() Position Triggers require a cyclic call in the Main Program because they need to constantly monitor the positions of registered movers. Properties .MoverPassedPosition Status boolean indicating that at least one mover has passed over the threshold position since being registered Position Triggers are unique in that the Current Mover output latches even though the mover may not still qualify under the trigger condition .CurrentMover Reference variable that refers to the earliest registered mover to cross over the track position since being registered If no movers are tracked, or no tracked movers have yet satisfied the objective, then .CurrentMover is an invalid reference. In this case, an ErrorMover will replace the invalid reference. The user will receive notifications when this happens in the TwinCAT event logs. See Diagnostics>ErrorMovers for more information. It is recommended that all evaluations are nested inside IF checks for .MoverPassedPosition. It is possible that multiple registered movers have crossed over a threshold position. Only the least recently valid mover handle is provided by .CurrentMover. To access more recent events, deregister the current mover with PositionTrigger.UnregisterCurrent() .TrackPosition Current placement of the Position Trigger threshold along the track Extra Examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Basic Position Trigger implementation // Begin monitoring Mover 1 IF bInit THEN Mover [ 1 ]. MoveToPosition ( 1000 ); PositionTrigger . TrackPosition := 800 ; PositionTrigger . RegisterMover ( Mover [ 1 ] ); bInit := FALSE ; END_IF // When Mover 1 crosses position 800, slow it down to 100mm/s IF PositionTrigger . MoverPassedPosition THEN PositionTrigger . CurrentMover . SetVelocity ( 100 ); PositionTrigger . UnregisterCurrent (); END_IF","title":"Position Trigger"},{"location":"CodeReference/PositionTrigger.html#position-trigger-object","text":"Position Trigger objects monitor movers until they have crossed over a specified location on track, even if they do not stop there.","title":"Position Trigger Object"},{"location":"CodeReference/PositionTrigger.html#setup-execution","text":"1 2 // Declaration PositionTriggerA : PositionTrigger ; 1 2 3 // Initialization PositionTriggerA . TrackPosition := 2000 ; PositionTriggerA . TriggerDirection := mcDirectionPositive ;","title":"Setup &amp; Execution"},{"location":"CodeReference/PositionTrigger.html#methods","text":"","title":"Methods"},{"location":"CodeReference/PositionTrigger.html#cyclic","text":"Cyclic() Position Triggers require a cyclic call in the Main Program because they need to constantly monitor the positions of registered movers.","title":"Cyclic"},{"location":"CodeReference/PositionTrigger.html#properties","text":"","title":"Properties"},{"location":"CodeReference/PositionTrigger.html#moverpassedposition","text":"Status boolean indicating that at least one mover has passed over the threshold position since being registered Position Triggers are unique in that the Current Mover output latches even though the mover may not still qualify under the trigger condition","title":".MoverPassedPosition"},{"location":"CodeReference/PositionTrigger.html#currentmover","text":"Reference variable that refers to the earliest registered mover to cross over the track position since being registered If no movers are tracked, or no tracked movers have yet satisfied the objective, then .CurrentMover is an invalid reference. In this case, an ErrorMover will replace the invalid reference. The user will receive notifications when this happens in the TwinCAT event logs. See Diagnostics>ErrorMovers for more information. It is recommended that all evaluations are nested inside IF checks for .MoverPassedPosition. It is possible that multiple registered movers have crossed over a threshold position. Only the least recently valid mover handle is provided by .CurrentMover. To access more recent events, deregister the current mover with PositionTrigger.UnregisterCurrent()","title":".CurrentMover"},{"location":"CodeReference/PositionTrigger.html#trackposition","text":"Current placement of the Position Trigger threshold along the track","title":".TrackPosition"},{"location":"CodeReference/PositionTrigger.html#extra-examples","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Basic Position Trigger implementation // Begin monitoring Mover 1 IF bInit THEN Mover [ 1 ]. MoveToPosition ( 1000 ); PositionTrigger . TrackPosition := 800 ; PositionTrigger . RegisterMover ( Mover [ 1 ] ); bInit := FALSE ; END_IF // When Mover 1 crosses position 800, slow it down to 100mm/s IF PositionTrigger . MoverPassedPosition THEN PositionTrigger . CurrentMover . SetVelocity ( 100 ); PositionTrigger . UnregisterCurrent (); END_IF","title":"Extra Examples"},{"location":"CodeReference/SpeedTrigger.html","text":"Speed Trigger Object Speed Trigger objects monitor movers until they have exceeded a specified velocity. Setup & Execution 1 2 // Declaration SpeedTriggerA : SpeedTrigger ; 1 2 // Initization SpeedTriggerA . ThresholdVelocity := 800 ; Properties .MoverInVelocity Status boolean indicating that at least one mover is currently exceeding the threshold velocity .CurrentMover Reference variable that refers to the earliest registered mover to exceed the threshold velocity since being registered If no movers are tracked, or no tracked movers currently satisfy the objective, then .CurrentMover is an invalid reference. In this case, an ErrorMover will replace the invalid reference. The user will receive notifications when this happens in the TwinCAT event logs. See Diagnostics>ErrorMovers for more information. It is recommended that all evaluations are nested inside IF check for .MoverInVelocity. It is possible that multiple registered movers simultaneously exceed the threshold velocity. Only the least recently valid mover handle is provided by .CurrentMover. To access more recent events, deregister the current mover with SpeedTrigger.UnregisterCurrent() .ThresholdVelocity Current velocity, above which a mover is considered 'In Velocity' Extra Examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Basic Speed Trigger implementation // Begin monitoring Mover 1 IF bInit THEN Mover [ 1 ]. MoveToPosition ( 1000 ); SpeedTrigger . ThresholdVelocity := 600 ; // mm/s bInit := FALSE ; END_IF // When Mover 1 accelerates past 600mm/s, slow it down to 100mm/s IF SpeedTrigger . MoverInVelocity THEN SpeedTrigger . CurrentMover . SetVelocity ( 100 ); SpeedTrigger . UnregisterCurrent (); END_IF","title":"Speed Trigger"},{"location":"CodeReference/SpeedTrigger.html#speed-trigger-object","text":"Speed Trigger objects monitor movers until they have exceeded a specified velocity.","title":"Speed Trigger Object"},{"location":"CodeReference/SpeedTrigger.html#setup-execution","text":"1 2 // Declaration SpeedTriggerA : SpeedTrigger ; 1 2 // Initization SpeedTriggerA . ThresholdVelocity := 800 ;","title":"Setup &amp; Execution"},{"location":"CodeReference/SpeedTrigger.html#properties","text":"","title":"Properties"},{"location":"CodeReference/SpeedTrigger.html#moverinvelocity","text":"Status boolean indicating that at least one mover is currently exceeding the threshold velocity","title":".MoverInVelocity"},{"location":"CodeReference/SpeedTrigger.html#currentmover","text":"Reference variable that refers to the earliest registered mover to exceed the threshold velocity since being registered If no movers are tracked, or no tracked movers currently satisfy the objective, then .CurrentMover is an invalid reference. In this case, an ErrorMover will replace the invalid reference. The user will receive notifications when this happens in the TwinCAT event logs. See Diagnostics>ErrorMovers for more information. It is recommended that all evaluations are nested inside IF check for .MoverInVelocity. It is possible that multiple registered movers simultaneously exceed the threshold velocity. Only the least recently valid mover handle is provided by .CurrentMover. To access more recent events, deregister the current mover with SpeedTrigger.UnregisterCurrent()","title":".CurrentMover"},{"location":"CodeReference/SpeedTrigger.html#thresholdvelocity","text":"Current velocity, above which a mover is considered 'In Velocity'","title":".ThresholdVelocity"},{"location":"CodeReference/SpeedTrigger.html#extra-examples","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Basic Speed Trigger implementation // Begin monitoring Mover 1 IF bInit THEN Mover [ 1 ]. MoveToPosition ( 1000 ); SpeedTrigger . ThresholdVelocity := 600 ; // mm/s bInit := FALSE ; END_IF // When Mover 1 accelerates past 600mm/s, slow it down to 100mm/s IF SpeedTrigger . MoverInVelocity THEN SpeedTrigger . CurrentMover . SetVelocity ( 100 ); SpeedTrigger . UnregisterCurrent (); END_IF","title":"Extra Examples"},{"location":"CodeReference/Station.html","text":"Station Object The Station object provides a fixed location for a Mover to stop at until it is ready to be released. A Station is a type of Objective, and provides a handle to the Mover object that is currently docked with the Station, allowing further motion commands to be issued to the Mover. Setup & Execution 1 2 // Declaration Station : ARRAY [ 0. . GVL . NUM_STATIONS - 1 ] OF Station ; 1 2 3 4 // Initialization Station [ 1 ]. TrackPosition := 250 ; Station [ 2 ]. TrackPosition := 500 ; Station [ 3 ]. TrackPosition := 750 ; 1 2 3 4 // Call this method cyclically FOR i := 0 TO GVL . NUM_STATIONS - 1 DO Station [ i ]. Cyclic (); END_FOR Mover Registration Unlike other types of Objectives, Stations manage mover registration automatically. Any mover that is commanded with a MoveToStation is also automatically registered with that station. As an example, this implementation would be redundant: 1 2 Mover [ 2 ]. MoveToStation ( Station [ 3 ] ); Station [ 3 ]. RegisterMover ( Mover [ 2 ] ); // unnecessary Stations also automatically unregister movers that have been redirected with another move command, even if that command's destination is the same as the Station. 1 2 Mover [ 2 ]. MoveToStation ( Station [ 3 ] ); Mover [ 2 ]. MoveToPosition ( Station [ 3 ]. TrackPosition ); Here, the Station will not report MoverInPosition . Methods Cyclic Cyclic() Stations require a cyclic call in the Main program. This allows the station to automatically unregister movers from its Tracked list who have been redirected and are no longer destined for this Station. 1 2 3 FOR i := 0 TO GVL . NUM_STATIONS - 1 DO Station [ i ]. Cyclic () END_FOR Properties .MoverInPosition Status boolean indicating that a mover is currently docked with the Station .CurrentMover Reference variable that refers to the Mover that is docked with the Station When no mover is present in the Station, .CurrentMover is an invalid reference. In this case, an ErrorMover will replace the invalid reference. The user will receive notifications when this happens in the TwinCAT Event Logs. It is recommended that all evaluations are nested inside IF checks for .MoverInPosition. .TrackedMoverCount Simply reports the number of Movers that are currently registered with the Station. Because Stations automatically deregister movers that are not currently destined for this Station, this value also represents the current number of incoming movers .TrackPosition Current placement of the Station along the track Extra Examples 1 2 3 4 5 6 7 8 9 10 // Basic Station implementation with a 1s dwell time IF Station [ 0 ]. MoverInPosition THEN StationTimer ( IN := TRUE , PT := T # 1000 MS ); // TON IF StationTimer . Q THEN Station [ 0 ]. CurrentMover . MoveToStation ( Station [ 1 ] ); END_IF ELSE StationTimer ( IN := FALSE ); END_IF 1 2 3 4 // Immediately redirect all incoming shuttles to Station 1 instead of Station 0 FOR i := 0 TO Station [ 0 ]. TrackedMoverCount - 1 DO Station [ 0 ]. TrackedMovers [ i ] ^ . MoveToStation ( Station [ 1 ] ); END_FOR","title":"Station"},{"location":"CodeReference/Station.html#station-object","text":"The Station object provides a fixed location for a Mover to stop at until it is ready to be released. A Station is a type of Objective, and provides a handle to the Mover object that is currently docked with the Station, allowing further motion commands to be issued to the Mover.","title":"Station Object"},{"location":"CodeReference/Station.html#setup-execution","text":"1 2 // Declaration Station : ARRAY [ 0. . GVL . NUM_STATIONS - 1 ] OF Station ; 1 2 3 4 // Initialization Station [ 1 ]. TrackPosition := 250 ; Station [ 2 ]. TrackPosition := 500 ; Station [ 3 ]. TrackPosition := 750 ; 1 2 3 4 // Call this method cyclically FOR i := 0 TO GVL . NUM_STATIONS - 1 DO Station [ i ]. Cyclic (); END_FOR","title":"Setup &amp; Execution"},{"location":"CodeReference/Station.html#mover-registration","text":"Unlike other types of Objectives, Stations manage mover registration automatically. Any mover that is commanded with a MoveToStation is also automatically registered with that station. As an example, this implementation would be redundant: 1 2 Mover [ 2 ]. MoveToStation ( Station [ 3 ] ); Station [ 3 ]. RegisterMover ( Mover [ 2 ] ); // unnecessary Stations also automatically unregister movers that have been redirected with another move command, even if that command's destination is the same as the Station. 1 2 Mover [ 2 ]. MoveToStation ( Station [ 3 ] ); Mover [ 2 ]. MoveToPosition ( Station [ 3 ]. TrackPosition ); Here, the Station will not report MoverInPosition .","title":"Mover Registration"},{"location":"CodeReference/Station.html#methods","text":"","title":"Methods"},{"location":"CodeReference/Station.html#cyclic","text":"Cyclic() Stations require a cyclic call in the Main program. This allows the station to automatically unregister movers from its Tracked list who have been redirected and are no longer destined for this Station. 1 2 3 FOR i := 0 TO GVL . NUM_STATIONS - 1 DO Station [ i ]. Cyclic () END_FOR","title":"Cyclic"},{"location":"CodeReference/Station.html#properties","text":"","title":"Properties"},{"location":"CodeReference/Station.html#moverinposition","text":"Status boolean indicating that a mover is currently docked with the Station","title":".MoverInPosition"},{"location":"CodeReference/Station.html#currentmover","text":"Reference variable that refers to the Mover that is docked with the Station When no mover is present in the Station, .CurrentMover is an invalid reference. In this case, an ErrorMover will replace the invalid reference. The user will receive notifications when this happens in the TwinCAT Event Logs. It is recommended that all evaluations are nested inside IF checks for .MoverInPosition.","title":".CurrentMover"},{"location":"CodeReference/Station.html#trackedmovercount","text":"Simply reports the number of Movers that are currently registered with the Station. Because Stations automatically deregister movers that are not currently destined for this Station, this value also represents the current number of incoming movers","title":".TrackedMoverCount"},{"location":"CodeReference/Station.html#trackposition","text":"Current placement of the Station along the track","title":".TrackPosition"},{"location":"CodeReference/Station.html#extra-examples","text":"1 2 3 4 5 6 7 8 9 10 // Basic Station implementation with a 1s dwell time IF Station [ 0 ]. MoverInPosition THEN StationTimer ( IN := TRUE , PT := T # 1000 MS ); // TON IF StationTimer . Q THEN Station [ 0 ]. CurrentMover . MoveToStation ( Station [ 1 ] ); END_IF ELSE StationTimer ( IN := FALSE ); END_IF 1 2 3 4 // Immediately redirect all incoming shuttles to Station 1 instead of Station 0 FOR i := 0 TO Station [ 0 ]. TrackedMoverCount - 1 DO Station [ 0 ]. TrackedMovers [ i ] ^ . MoveToStation ( Station [ 1 ] ); END_FOR","title":"Extra Examples"},{"location":"CodeReference/Zone.html","text":"Zone Object The Zone object provides a method for grabbing all Movers within a specified geographic area on the track. A Zone is defined by a Start Position and an End Position, and returns every mover between these points. Zones are especially useful for programming recovery scenarios. Setup & Execution 1 2 3 // Declaration ZoneLeftSide : Zone ; ZoneRightSide : Zone ; 1 2 3 4 5 6 // Initialization ZoneLeftSide . StartPosition := 0 ; ZoneLeftSide . EndPosition := 2000 ; ZoneRightSide . StartPosition := 2000 ; ZoneRightSide . EndPosition := 4000 ; Methods GetMover GetMover( Index : USINT, Direction : Tc2_MC2.MC_Direction) : REFERENCE TO Mover Provides a reference to the Mover that has n = Index movers between it and the end of the Zone specified by the Direction 1 2 3 4 5 6 7 // Selects the mover closest to the Zone's End Position // Then issues a motion command ZoneLeftSide . GetMover ( 0 , MC_Positive_Direction ). MoveToPosition ( 2000 ); // Selects the fourth-closest mover to the Zone's Start Position // Then sets its velocity ZoneRightSide . GetMover ( 3 , MC_Negative_Direction ). SetVelocity ( 1200 ); Properties .CurrentMoverList Provides a MoverList object reference, containing all Movers that are currently within the boundaries set by Start Position and End Position. As a MoverList, methods are provided to command all movers as a group. See MoverList objective for more information 1 2 3 4 5 6 7 8 // Command all movers from position 0 through 2000 to Station#1 ZoneLeftSide . CurrentMoverList . MoveAllToStation ( Station [ 1 ] ); // Command all movers from position 2000 through 4000 to Station#2 ZoneRightSide . CurrentMoverList . MoveAllToStation ( Station [ 2 ] ); // Command the singular mover which is closest to the end of the zone to Station#3 Zone . CurrentMoverList . GetMoverByLocation ( 0 , Zone . EndPosition , MC_Positive_Direction ). MoveToStation ( Station [ 3 ] ); .StartPosition Defines the lower bound for the track region considered by the Zone object. .EndPosition Defines the upper bound for the track region considered by the Zone object. .ZoneLength Calculates the length of the defined zone, in millimeters.","title":"Zone"},{"location":"CodeReference/Zone.html#zone-object","text":"The Zone object provides a method for grabbing all Movers within a specified geographic area on the track. A Zone is defined by a Start Position and an End Position, and returns every mover between these points. Zones are especially useful for programming recovery scenarios.","title":"Zone Object"},{"location":"CodeReference/Zone.html#setup-execution","text":"1 2 3 // Declaration ZoneLeftSide : Zone ; ZoneRightSide : Zone ; 1 2 3 4 5 6 // Initialization ZoneLeftSide . StartPosition := 0 ; ZoneLeftSide . EndPosition := 2000 ; ZoneRightSide . StartPosition := 2000 ; ZoneRightSide . EndPosition := 4000 ;","title":"Setup &amp; Execution"},{"location":"CodeReference/Zone.html#methods","text":"","title":"Methods"},{"location":"CodeReference/Zone.html#getmover","text":"GetMover( Index : USINT, Direction : Tc2_MC2.MC_Direction) : REFERENCE TO Mover Provides a reference to the Mover that has n = Index movers between it and the end of the Zone specified by the Direction 1 2 3 4 5 6 7 // Selects the mover closest to the Zone's End Position // Then issues a motion command ZoneLeftSide . GetMover ( 0 , MC_Positive_Direction ). MoveToPosition ( 2000 ); // Selects the fourth-closest mover to the Zone's Start Position // Then sets its velocity ZoneRightSide . GetMover ( 3 , MC_Negative_Direction ). SetVelocity ( 1200 );","title":"GetMover"},{"location":"CodeReference/Zone.html#properties","text":"","title":"Properties"},{"location":"CodeReference/Zone.html#currentmoverlist","text":"Provides a MoverList object reference, containing all Movers that are currently within the boundaries set by Start Position and End Position. As a MoverList, methods are provided to command all movers as a group. See MoverList objective for more information 1 2 3 4 5 6 7 8 // Command all movers from position 0 through 2000 to Station#1 ZoneLeftSide . CurrentMoverList . MoveAllToStation ( Station [ 1 ] ); // Command all movers from position 2000 through 4000 to Station#2 ZoneRightSide . CurrentMoverList . MoveAllToStation ( Station [ 2 ] ); // Command the singular mover which is closest to the end of the zone to Station#3 Zone . CurrentMoverList . GetMoverByLocation ( 0 , Zone . EndPosition , MC_Positive_Direction ). MoveToStation ( Station [ 3 ] );","title":".CurrentMoverList"},{"location":"CodeReference/Zone.html#startposition","text":"Defines the lower bound for the track region considered by the Zone object.","title":".StartPosition"},{"location":"CodeReference/Zone.html#endposition","text":"Defines the upper bound for the track region considered by the Zone object.","title":".EndPosition"},{"location":"CodeReference/Zone.html#zonelength","text":"Calculates the length of the defined zone, in millimeters.","title":".ZoneLength"},{"location":"Examples/StationRouting.html","text":"Station Routing This example demonstrates the most basic Station to Station type routing. There are two stations, which each dwell for a period of time before forwarding movers to the next station in the sequence 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 MS_RUN : // ----------------------------------- OPERATING // Station 0 Logic IF Station [ 0 ]. MoverInPosition THEN StationTimer [ 0 ]( IN := TRUE , PT := T # 1000 MS ); IF StationTimer [ 0 ]. Q THEN Station [ 0 ]. CurrentMover . SetVelocity ( 500 ); Station [ 0 ]. CurrentMover . MoveToStation ( Station [ 1 ] ); END_IF ELSE // Reset the timer for the next mover StationTimer [ 0 ]( IN := FALSE ); END_IF // Station 1 Logic IF Station [ 1 ]. MoverInPosition THEN StationTimer [ 1 ]( IN := TRUE , PT := T # 2 s ); IF StationTimer [ 1 ]. Q THEN // Same behavior as above, but utilizing method chaining Station [ 1 ]. CurrentMover . SetVelocity ( 90 ). MoveToStation ( Station [ 0 ] ); END_IF ELSE // Reset the timer for the next mover StationTimer [ 1 ]( IN := FALSE ); END_IF","title":"Station Routing"},{"location":"Examples/StationRouting.html#station-routing","text":"This example demonstrates the most basic Station to Station type routing. There are two stations, which each dwell for a period of time before forwarding movers to the next station in the sequence 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 MS_RUN : // ----------------------------------- OPERATING // Station 0 Logic IF Station [ 0 ]. MoverInPosition THEN StationTimer [ 0 ]( IN := TRUE , PT := T # 1000 MS ); IF StationTimer [ 0 ]. Q THEN Station [ 0 ]. CurrentMover . SetVelocity ( 500 ); Station [ 0 ]. CurrentMover . MoveToStation ( Station [ 1 ] ); END_IF ELSE // Reset the timer for the next mover StationTimer [ 0 ]( IN := FALSE ); END_IF // Station 1 Logic IF Station [ 1 ]. MoverInPosition THEN StationTimer [ 1 ]( IN := TRUE , PT := T # 2 s ); IF StationTimer [ 1 ]. Q THEN // Same behavior as above, but utilizing method chaining Station [ 1 ]. CurrentMover . SetVelocity ( 90 ). MoveToStation ( Station [ 0 ] ); END_IF ELSE // Reset the timer for the next mover StationTimer [ 1 ]( IN := FALSE ); END_IF","title":"Station Routing"},{"location":"GettingStarted/GettingStarted.html","text":"Getting Started Project Requirements For new projects, the latest versions of TwinCAT and XTS software should be utilized. All XTS projects will require: TF5850 TF5410 Configuring XTS Hardware The base project includes a simulated configuration for a 4m oval track and 6 movers. In order to modify the program to fit a different track configuration, navigate to the XTS Tool Window. Then launch the XTS Configurator and follow the prompts to configure your system. The configurator occasionally conflicts with existing settings in the project. To avoid this, it can help to delete the following prior to running the XTS Configurator: XtsProcessingUnit All Mover Axis Object Existing XTS_Task Any hardware in the IO section. Initialization Settings Once your hardware configuration is set, you will need to change a few variable parameters in the code to match the system. Inside MOTION > Objects > Collision Avoidance (CA Group) , set the Rail Length parameter to match your hardware. Next, open the GVL file within PLC and modify these constants to match your system. Next, check that each of your Axis objects are properly linked to a corresponding Mover object. !!! Note The project contains ErrorMover objects which also appear as options when linking axes. Do not link axes to these variables. Lastly, open the XtsProcessingUnit within SYSTEM and verify that every setting here is correct","title":"First Steps"},{"location":"GettingStarted/GettingStarted.html#getting-started","text":"","title":"Getting Started"},{"location":"GettingStarted/GettingStarted.html#project-requirements","text":"For new projects, the latest versions of TwinCAT and XTS software should be utilized. All XTS projects will require: TF5850 TF5410","title":"Project Requirements"},{"location":"GettingStarted/GettingStarted.html#configuring-xts-hardware","text":"The base project includes a simulated configuration for a 4m oval track and 6 movers. In order to modify the program to fit a different track configuration, navigate to the XTS Tool Window. Then launch the XTS Configurator and follow the prompts to configure your system. The configurator occasionally conflicts with existing settings in the project. To avoid this, it can help to delete the following prior to running the XTS Configurator: XtsProcessingUnit All Mover Axis Object Existing XTS_Task Any hardware in the IO section.","title":"Configuring XTS Hardware"},{"location":"GettingStarted/GettingStarted.html#initialization-settings","text":"Once your hardware configuration is set, you will need to change a few variable parameters in the code to match the system. Inside MOTION > Objects > Collision Avoidance (CA Group) , set the Rail Length parameter to match your hardware. Next, open the GVL file within PLC and modify these constants to match your system. Next, check that each of your Axis objects are properly linked to a corresponding Mover object. !!! Note The project contains ErrorMover objects which also appear as options when linking axes. Do not link axes to these variables. Lastly, open the XtsProcessingUnit within SYSTEM and verify that every setting here is correct","title":"Initialization Settings"},{"location":"GettingStarted/Introduction.html","text":"Introduction This site serves as reference documentation for the XTS Base Project. This site is not intended as a complete training guide on the XTS system, and contains no information on the electrical or mechanical setup of the system. Additional Resources Project Github Beckhoff XTS Page","title":"Introduction"},{"location":"GettingStarted/Introduction.html#introduction","text":"This site serves as reference documentation for the XTS Base Project. This site is not intended as a complete training guide on the XTS system, and contains no information on the electrical or mechanical setup of the system.","title":"Introduction"},{"location":"GettingStarted/Introduction.html#additional-resources","text":"Project Github Beckhoff XTS Page","title":"Additional Resources"},{"location":"GettingStarted/QuickTips.html","text":"Programming Quick Tips Here are a few quick tips to assist in developing with this project: Methods are designed to be called once, not repeatedly. Collision avoidance should be the source of buffering, there should rarely be a reason for a buffer location to be user defined. Movers Contain an AxisRef, it can be useful to put 'Mover[i].AxisReference.ReadStatus();' in the code with the Cyclic call for the same, the Status values of an AxisRef can be very useful. 1 2 3 4 5 // Call this method cyclically FOR i := 0 TO GVL . NUM_MOVERS - 1 ] DO Mover [ i ]. Cyclic ( GroupRef ); Mover [ i ]. AxisReference . ReadStatus (); END_FOR When using .CurrentMover properties (or similar), always wrap usage with a check for .MoverInPosition or similar, to verify that the pointers are valid. See ErrorMovers for more information. When reconfiguring the project for new hardware, be sure to delete elements of a previous configuration. More info on this is included in the First Steps section. When configuring new hardware, be sure that Is Closed and Is Included in Detection options are set correctly. When programming recovery scenarios, be sure to unregister movers from objectives where necessary. General Track Tips More generally, here are some recommendations regarding the architecture of your solution: Proper code should not depend on the number of movers added to the system, and should be easily scalable when movers are added or removed from the system. Directly addressing specific movers by ID should be avoided when possible. See Overview for more information. \"The fleet sails as fast as the slowest ship.\" Overall system throughput is governed by the slowest individual Station's throughput. Focus on understanding the limiting factors of your routing logic in order to optimize traffic flow. A Mover's maximum velocity rarely affects the overall system throughput.","title":"Quick Tips"},{"location":"GettingStarted/QuickTips.html#programming-quick-tips","text":"Here are a few quick tips to assist in developing with this project: Methods are designed to be called once, not repeatedly. Collision avoidance should be the source of buffering, there should rarely be a reason for a buffer location to be user defined. Movers Contain an AxisRef, it can be useful to put 'Mover[i].AxisReference.ReadStatus();' in the code with the Cyclic call for the same, the Status values of an AxisRef can be very useful. 1 2 3 4 5 // Call this method cyclically FOR i := 0 TO GVL . NUM_MOVERS - 1 ] DO Mover [ i ]. Cyclic ( GroupRef ); Mover [ i ]. AxisReference . ReadStatus (); END_FOR When using .CurrentMover properties (or similar), always wrap usage with a check for .MoverInPosition or similar, to verify that the pointers are valid. See ErrorMovers for more information. When reconfiguring the project for new hardware, be sure to delete elements of a previous configuration. More info on this is included in the First Steps section. When configuring new hardware, be sure that Is Closed and Is Included in Detection options are set correctly. When programming recovery scenarios, be sure to unregister movers from objectives where necessary.","title":"Programming Quick Tips"},{"location":"GettingStarted/QuickTips.html#general-track-tips","text":"More generally, here are some recommendations regarding the architecture of your solution: Proper code should not depend on the number of movers added to the system, and should be easily scalable when movers are added or removed from the system. Directly addressing specific movers by ID should be avoided when possible. See Overview for more information. \"The fleet sails as fast as the slowest ship.\" Overall system throughput is governed by the slowest individual Station's throughput. Focus on understanding the limiting factors of your routing logic in order to optimize traffic flow. A Mover's maximum velocity rarely affects the overall system throughput.","title":"General Track Tips"}]}